<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MS_Course_Project_Doxygen: src/Source_Files/i2c.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MS_Course_Project_Doxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('i2c_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">i2c.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains all the I2C driver functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;i2c.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3d74e3a730c761f8adad646b4c696df6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a3d74e3a730c761f8adad646b4c696df6">i2c_bus_reset</a> (I2C_TypeDef *i2c)</td></tr>
<tr class="memdesc:a3d74e3a730c761f8adad646b4c696df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responsible for resetting the bus for specified i2c_typedef.  <a href="i2c_8c.html#a3d74e3a730c761f8adad646b4c696df6">More...</a><br /></td></tr>
<tr class="separator:a3d74e3a730c761f8adad646b4c696df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bfa7f510f6de207f3ca138987211d6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a76bfa7f510f6de207f3ca138987211d6">i2c_ack</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *ism)</td></tr>
<tr class="memdesc:a76bfa7f510f6de207f3ca138987211d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ACKNOWLEDGEMENT of process during flowchart progression.  <a href="i2c_8c.html#a76bfa7f510f6de207f3ca138987211d6">More...</a><br /></td></tr>
<tr class="separator:a76bfa7f510f6de207f3ca138987211d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a1d90b9e8721f3757016414c1952f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ab4a1d90b9e8721f3757016414c1952f8">i2c_nack</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *ism)</td></tr>
<tr class="memdesc:ab4a1d90b9e8721f3757016414c1952f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOT ACKNOWLEDGEMENT of data received in the sensor.  <a href="i2c_8c.html#ab4a1d90b9e8721f3757016414c1952f8">More...</a><br /></td></tr>
<tr class="separator:ab4a1d90b9e8721f3757016414c1952f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b72591c735d4e2620c2774dbac83fa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a37b72591c735d4e2620c2774dbac83fa">i2c_rxstate</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *ism)</td></tr>
<tr class="memdesc:a37b72591c735d4e2620c2774dbac83fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads value from the Si7021 or SHTC3 based on # bytes specified.  <a href="i2c_8c.html#a37b72591c735d4e2620c2774dbac83fa">More...</a><br /></td></tr>
<tr class="separator:a37b72591c735d4e2620c2774dbac83fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f64c4799aa4ca85df3f873660b417de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a1f64c4799aa4ca85df3f873660b417de">i2c_mstop</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *ism)</td></tr>
<tr class="memdesc:a1f64c4799aa4ca85df3f873660b417de"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of flowchart operations, terminates and adds event to event scheduler.  <a href="i2c_8c.html#a1f64c4799aa4ca85df3f873660b417de">More...</a><br /></td></tr>
<tr class="separator:a1f64c4799aa4ca85df3f873660b417de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd501191443ae27fa7ab059461676249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#afd501191443ae27fa7ab059461676249">i2c_open</a> (I2C_TypeDef *i2c, <a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *i2c_setup)</td></tr>
<tr class="memdesc:afd501191443ae27fa7ab059461676249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init i2c related items and enables interrupts.  <a href="i2c_8c.html#afd501191443ae27fa7ab059461676249">More...</a><br /></td></tr>
<tr class="separator:afd501191443ae27fa7ab059461676249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd719a5a531ecd6bb89c183614d0f508"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#acd719a5a531ecd6bb89c183614d0f508">i2c_start</a> (I2C_TypeDef *i2c, uint32_t dadd, uint32_t *rec_data, uint32_t sensor_cmd, uint32_t bytes_num, uint32_t bytes_w, bool busy, bool rw, uint32_t callback)</td></tr>
<tr class="memdesc:acd719a5a531ecd6bb89c183614d0f508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the entire state_machine flowchart operation suite.  <a href="i2c_8c.html#acd719a5a531ecd6bb89c183614d0f508">More...</a><br /></td></tr>
<tr class="separator:acd719a5a531ecd6bb89c183614d0f508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">I2C0_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles interrupts and directs to specific interrupt ops ack, nack, rxstate or mstop.  <a href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">More...</a><br /></td></tr>
<tr class="separator:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45e5675f6f4e6e1dee2273baf245219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ac45e5675f6f4e6e1dee2273baf245219">I2C1_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:ac45e5675f6f4e6e1dee2273baf245219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles interrupts and directs to specific interrupt ops ack, nack, rxstate or mstop.  <a href="i2c_8c.html#ac45e5675f6f4e6e1dee2273baf245219">More...</a><br /></td></tr>
<tr class="separator:ac45e5675f6f4e6e1dee2273baf245219"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a95c6cc1a5faa8e0c415fd13eb080500c"><td class="memItemLeft" align="right" valign="top"><a id="a95c6cc1a5faa8e0c415fd13eb080500c" name="a95c6cc1a5faa8e0c415fd13eb080500c"></a>
static <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c0_state_machine</b></td></tr>
<tr class="separator:a95c6cc1a5faa8e0c415fd13eb080500c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2b258bd14b04a2a43116105e1fef89"><td class="memItemLeft" align="right" valign="top"><a id="a3f2b258bd14b04a2a43116105e1fef89" name="a3f2b258bd14b04a2a43116105e1fef89"></a>
static <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c1_state_machine</b></td></tr>
<tr class="separator:a3f2b258bd14b04a2a43116105e1fef89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Contains all the I2C driver functions. </p>
<dl class="section author"><dt>Author</dt><dd>Matthew Su </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/6/2022  </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8e817e99d2a59e5f48e4ff0c79e7eef5" name="a8e817e99d2a59e5f48e4ff0c79e7eef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e817e99d2a59e5f48e4ff0c79e7eef5">&#9670;&#160;</a></span>I2C0_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C0_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles interrupts and directs to specific interrupt ops ack, nack, rxstate or mstop. </p>
<p >Designed to be automatically called when interrupt is specified in order to direct it to correct function within it's available options. This handler is specifically for I2C0</p>
<dl class="section note"><dt>Note</dt><dd>Already referenced in source code, no need to declare it in <a class="el" href="i2c_8h_source.html">i2c.h</a> </dd></dl>

</div>
</div>
<a id="ac45e5675f6f4e6e1dee2273baf245219" name="ac45e5675f6f4e6e1dee2273baf245219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45e5675f6f4e6e1dee2273baf245219">&#9670;&#160;</a></span>I2C1_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles interrupts and directs to specific interrupt ops ack, nack, rxstate or mstop. </p>
<p >Designed to be automatically called when interrupt is specified in order to direct it to correct function within it's available options. This handler is specifically for I2C1</p>
<dl class="section note"><dt>Note</dt><dd>Already referenced in source code, no need to declare it in <a class="el" href="i2c_8h_source.html">i2c.h</a> </dd></dl>

</div>
</div>
<a id="a76bfa7f510f6de207f3ca138987211d6" name="a76bfa7f510f6de207f3ca138987211d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bfa7f510f6de207f3ca138987211d6">&#9670;&#160;</a></span>i2c_ack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_ack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>ism</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ACKNOWLEDGEMENT of process during flowchart progression. </p>
<p >Called multiple times in order to make sure progression within the flowchart is correct. Once acked, different enum states contain different ops relating to the recording of data reported by the Si7021 and SHTC3 during a sensor_cmd. After each ack, it progresses to a new state.</p>
<p >States that occur in the ack are described as follows;</p>
<p >INITILAIZATION STATE: Where the ack starts and the first state set by i2c_start. A "read or write" boolean determines the course of action that all the other acks will take.</p>
<p >If read, will write to TXDATA the accompanying sensor command and shifted based on bytesw, a num value that will determine both the increment of 8 required to be shifted by as well as the number of writes that will occur. It's dual purpose does not affect SI7021 read ops, as when set to 0 it performs the normal TXDATA write without any shift and moves on to the SET_REG state. For the SHTC3, it will use the bytesw value to write the sensor_cmd in MSB and LSB segments to the register before it starts its actual read operation.</p>
<p >If write, then it will direct the ack to the WX_STATE and perform the first write op to follow to the WX_STATE.</p>
<p >WX_STATE: Instead of in it's own dedicated function, it was kept in the ack during the initial build and testing phase of the state. There seemed no reason to move it after so it remains within the ack itself. It replicates the same process as in the if statement for the read version of the INITILAZATION STATE, which also uses the bytesw to iterate a specific number of times and passing the MSB and LSB of the sensor command. Once it finishes it will direct immediatly to CLOSE_PROCESS</p>
<p >SET_REG: Sets the next state to HOLD, resends a START command, and sets the register with the address of the device SI7021 or SHTC3</p>
<p >HOLD: Holds for a round of ack. Sets the next state to the RX_STATE.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>For some reason in the INITILAIZATION STATE, for the write branch the ops could not all be completed in the WX_STATE itself, either doing one too many or one too few. This solution was to perform the first write op locally in the I_S before moving to the WX_STATE. It's jank but was validated to be a working solution so it was kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_STATE_MACHINE*</td><td>ism Pointer to address of global state_machine specified either to be I2C0 or I2C1 by the respective IRQ_handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d74e3a730c761f8adad646b4c696df6" name="a3d74e3a730c761f8adad646b4c696df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d74e3a730c761f8adad646b4c696df6">&#9670;&#160;</a></span>i2c_bus_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_bus_reset </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responsible for resetting the bus for specified i2c_typedef. </p>
<p >Sends out any resets and clears flags, thus reseting the bus for i2c. Called at the end of i2c_start to clear previous op status and reset for new round</p>
<dl class="section note"><dt>Note</dt><dd>Ensure that the i2c peripheral state machine is available to accept a command by sending the ABORT command to the I2C peripheral to reset it’s internal state machine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_TypeDef</td><td>*i2c Pointer to the base peripheral address of I2C0 or I2C1 which will be reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f64c4799aa4ca85df3f873660b417de" name="a1f64c4799aa4ca85df3f873660b417de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f64c4799aa4ca85df3f873660b417de">&#9670;&#160;</a></span>i2c_mstop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_mstop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>ism</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of flowchart operations, terminates and adds event to event scheduler. </p>
<p >Hardstop that the state_machine flowchart will come to at end of ops, unblocks sleep mode, sets the state_machine to not busy, and adds scheduled event to the scheduler so it can start the process of translating and reporting the humidity value. Takes care of state CLOSED_PROCESS;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_STATE_MACHINE*</td><td>ism Pointer to address of global state_machine specified either to be I2C0 or I2C1 by the respective IRQ_handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4a1d90b9e8721f3757016414c1952f8" name="ab4a1d90b9e8721f3757016414c1952f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a1d90b9e8721f3757016414c1952f8">&#9670;&#160;</a></span>i2c_nack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_nack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>ism</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NOT ACKNOWLEDGEMENT of data received in the sensor. </p>
<p >Waits during HOLD state to make sure data is received and a restart is passed, ops for state HOLD only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_STATE_MACHINE*</td><td>ism Pointer to address of global state_machine specified either to be I2C0 or I2C1 by the respective IRQ_handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd501191443ae27fa7ab059461676249" name="afd501191443ae27fa7ab059461676249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd501191443ae27fa7ab059461676249">&#9670;&#160;</a></span>i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_open </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *&#160;</td>
          <td class="paramname"><em>i2c_setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init i2c related items and enables interrupts. </p>
<p >Looks to enable values in the I2C_Init_TypeDef, maually defined in this function and enabled according to what we need, in this case clock freqs, pinouts, routepins, etc. Additionally, interrupts for ACK, NACK, RXDATAv and MSTOP are enabled.</p>
<dl class="section note"><dt>Note</dt><dd>This function is normally called once to initialize the peripheral and the function <a class="el" href="i2c_8c.html#acd719a5a531ecd6bb89c183614d0f508" title="Starts the entire state_machine flowchart operation suite.">i2c_start()</a> is called to turn-on the Si7021/SHTC3 ops.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_TypeDef</td><td>*i2c Pointer to the base peripheral address of I2C0 or I2C1 which will be used</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a></td><td>*i2c_setup Is the STRUCT that the calling routine will use to set the parameters for i2c ops. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37b72591c735d4e2620c2774dbac83fa" name="a37b72591c735d4e2620c2774dbac83fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b72591c735d4e2620c2774dbac83fa">&#9670;&#160;</a></span>i2c_rxstate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_rxstate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>ism</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads value from the Si7021 or SHTC3 based on # bytes specified. </p>
<p >Reads value from the Si7021/SHTC3 based on # bytes specified, when operation is complete, sends two commands NACK and STOP. Takes care of state RX_STATE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_STATE_MACHINE*</td><td>ism Pointer to address of global state_machine specified either to be I2C0 or I2C1 by the respective IRQ_handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd719a5a531ecd6bb89c183614d0f508" name="acd719a5a531ecd6bb89c183614d0f508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd719a5a531ecd6bb89c183614d0f508">&#9670;&#160;</a></span>i2c_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_start </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dadd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rec_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensor_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>busy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the entire state_machine flowchart operation suite. </p>
<p >Responsible for starting the specified global machine by setting values based on specified i2c_typedef values and ACKs, allowing for state_machine_tree to start working through it's eventually command operations to read the Si7021 sensor and eventually complete its ops and return to main</p>
<dl class="section note"><dt>Note</dt><dd>Input values can also be passed as the pointer to a state_machine struct called locally in the function for which this function is called. ATM, it was not implemented to ensure that values were being input and received. Updated from lab 5 to include items for SHTC3 operation.</dd></dl>
<p>Additionally descriptions of parameters directly correspond to what can be found in the STATE_MACHINE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_TypeDef</td><td>*i2c Pointer to the base peripheral address of I2C0 or I2C1 which will be reset</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>dadd Device Address, known value of 0x40 that has been defined in <a class="el" href="_si7021_8h_source.html">Si7021.h</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t*</td><td>rec_data Pointer to address where a static uint32_t value stores the data generated by the Si7021 sensor when it reads the humidity.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>sensor_cmd Specific sensor command for Si7021 or SHTC3 specific operations. Can take in a 1 or two byte command.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>bytes_num Number of bytes to be read. Controls number of iterations of read ops in RX_STATE for Si7021 and SHTC3 variations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>bytes_w Number of bytes to be written. Controls number of iterations of write ops in WX_STATE and INITILAIZATION STATE. Exclusively useful for the MSB and LSB portions of the sensor_cmd related to the SHTC3 hum and temp commands, represented as 1 during i2c_start call. It also controls the number of 8 shifts required during the passing of the sensor command, passing MSB (8*1) then LSB (8*0).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bool</td><td>busy Bool value that blocks operation unless it is specified that a state_machine is not busy</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bool</td><td>rw Bool value that determines either read (1) or write (0) operation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>callback CALLBACK value that when placed into the scheduler is recognized and executes Si7021/SHTC3 related ops to generate an output for humidity and temperature </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2855980263c52be09af3085e80bd06a7.html">Source_Files</a></li><li class="navelem"><a class="el" href="i2c_8c.html">i2c.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
